#!/usr/bin/perl
#
#	Converter for ASN CSV database to binary, for xt_asn
#	Copyright Â© Jan Engelhardt, 2008-2011
#	Rebuild for xt_asn by Moriarti <mor.moriarti@gmail.com>, 2017
use Getopt::Long;
use IO::Handle;
use Text::CSV_XS; # or trade for Text::CSV
use strict;

my $csv = Text::CSV_XS->new({
	allow_whitespace => 1,
	binary => 1,
	auto_diag => 1,
}); # or Text::CSV
my $target_dir = ".";
my $help = 0;

sub show_help {
	print <<EOF;
Usage: $0 [OPTIONS] [INPUT_FILE]

Convert ASN CSV data to binary format for xt_asn kernel module.

OPTIONS:
  -D DIR          Target directory for output files (default: current dir)
  -h, --help      Show this help message

INPUT:
  INPUT_FILE      CSV file with ASN data (if not specified, reads from stdin)
                  Format: start_ip,end_ip,start_num,end_num,asn,description

Examples:
  $0 -D /usr/share/xt_asn asn_data.csv
  cat asn_data.csv | $0 -D /usr/share/xt_asn

Note: The script expects CSV data with the following format:
  IPv4: start_ip,end_ip,start_num,end_num,asn,description
  IPv6: start_ip,end_ip,,,,asn,description

EOF
}

&Getopt::Long::Configure(qw(bundling));
&GetOptions(
	"D=s" => \$target_dir,
	"h|help" => \$help,
);

if ($help) {
	show_help();
	exit 0;
}

# Check if target directory exists
if (!-d $target_dir) {
	print STDERR "Target directory $target_dir does not exist.\n";
	exit 1;
}

# Create LE and BE subdirectories
foreach (qw(LE BE)) {
	my $dir = "$target_dir/$_";
	if (!-e $dir && !mkdir($dir)) {
		print STDERR "Could not mkdir $dir: $!\n";
		exit 1;
	}
}

# Check if we have input data
if (@ARGV == 0 && -t STDIN) {
	print STDERR "Error: No input file specified and no data piped to stdin.\n";
	print STDERR "Use -h or --help for usage information.\n";
	exit 1;
}

# Verify input file exists if specified
if (@ARGV > 0) {
	foreach my $file (@ARGV) {
		if (!-f $file) {
			print STDERR "Error: Input file '$file' does not exist or is not readable.\n";
			exit 1;
		}
		if (!-r $file) {
			print STDERR "Error: Input file '$file' is not readable.\n";
			exit 1;
		}
	}
}

print STDERR "Processing ASN data...\n";
&dump(&collect());

sub collect
{
	my %asn;
	my $line_count = 0;
	my $errors = 0;

	while (my $row = $csv->getline(*ARGV)) {
		$line_count++;
		
		# Skip empty lines or lines with insufficient columns
		if (!defined($row) || @$row < 6) {
			$errors++;
			if ($errors > 10) {
				print STDERR "\nToo many parsing errors. Stopping.\n";
				exit 1;
			}
			next;
		}
		
		# Extract ASN number (column 4) and name (column 5)
		my $asn_num = $row->[4];
		my $asn_name = $row->[5] || "Unknown";
		
		# Skip if ASN number is invalid
		if (!defined($asn_num) || $asn_num !~ /^\d+$/) {
			next;
		}
		
		# Initialize ASN entry if not exists
		if (!defined($asn{$asn_num})) {
			$asn{$asn_num} = {
				name => $asn_name,
				pool_v4 => [],
				pool_v6 => [],
			};
		}
		
		my $c = $asn{$asn_num};
		
		# Check if this is IPv6 (contains colons)
		if ($row->[0] =~ /:/) {
			eval {
				push(@{$c->{pool_v6}},
				     [&ip6_pack($row->[0]), &ip6_pack($row->[1])]);
			};
			if ($@) {
				print STDERR "Warning: IPv6 parsing error at line $line_count: $@\n";
				$errors++;
			}
		} else {
			# IPv4 - use numeric values from columns 2 and 3
			if (defined($row->[2]) && defined($row->[3]) && 
			    $row->[2] =~ /^\d+$/ && $row->[3] =~ /^\d+$/) {
				push(@{$c->{pool_v4}}, [$row->[2], $row->[3]]);
			} else {
				print STDERR "Warning: Invalid IPv4 range at line $line_count\n";
				$errors++;
			}
		}
		
		# Progress indicator
		if ($line_count % 4096 == 0) {
			print STDERR "\r\e[2K$line_count entries processed";
		}
	}

	# Check for CSV parsing errors (but ignore EOF which is normal)
	if (my $error = $csv->error_diag()) {
		my $error_code = $csv->error_diag() + 0;  # Get numeric error code
		if ($error_code != 2012) {  # 2012 is EOF - End of data, which is normal
			print STDERR "\nCSV parsing error: $error\n";
			exit 1;
		}
	}

	print STDERR "\r\e[2K$line_count entries total";
	if ($errors > 0) {
		print STDERR " ($errors errors)";
	}
	print STDERR "\n";
	
	# Check if we got any data
	if (keys %asn == 0) {
		print STDERR "Error: No valid ASN data found in input.\n";
		exit 1;
	}
	
	printf STDERR "Found %d unique ASN numbers\n", scalar(keys %asn);
	return \%asn;
}

sub dump
{
	my $asn = shift @_;

	foreach my $iso_code (sort keys %$asn) {
		&dump_one($iso_code, $asn->{$iso_code});
	}
}

sub dump_one
{
	my($iso_code, $asn) = @_;
	my($file, $fh_le, $fh_be);

	printf "%5u IPv6 ranges for %s %s\n",
		scalar(@{$asn->{pool_v6}}),
		$iso_code, $asn->{name};

	$file = "$target_dir/LE/".uc($iso_code).".iv6";
	if (!open($fh_le, "> $file")) {
		print STDERR "Error opening $file: $!\n";
		exit 1;
	}
	$file = "$target_dir/BE/".uc($iso_code).".iv6";
	if (!open($fh_be, "> $file")) {
		print STDERR "Error opening $file: $!\n";
		exit 1;
	}
	foreach my $range (@{$asn->{pool_v6}}) {
		print $fh_be $range->[0], $range->[1];
		print $fh_le &ip6_swap($range->[0]), &ip6_swap($range->[1]);
	}
	close $fh_le;
	close $fh_be;

	printf "%5u IPv4 ranges for %s %s\n",
		scalar(@{$asn->{pool_v4}}),
		$iso_code, $asn->{name};

	$file = "$target_dir/LE/".uc($iso_code).".iv4";
	if (!open($fh_le, "> $file")) {
		print STDERR "Error opening $file: $!\n";
		exit 1;
	}
	$file = "$target_dir/BE/".uc($iso_code).".iv4";
	if (!open($fh_be, "> $file")) {
		print STDERR "Error opening $file: $!\n";
		exit 1;
	}
	foreach my $range (@{$asn->{pool_v4}}) {
		print $fh_le pack("VV", $range->[0], $range->[1]);
		print $fh_be pack("NN", $range->[0], $range->[1]);
	}
	close $fh_le;
	close $fh_be;
}

sub ip6_pack
{
	my $addr = shift @_;
	$addr =~ s{::}{:!:};
	my @addr = split(/:/, $addr);
	my @e = (0) x 8;
	foreach (@addr) {
		if ($_ eq "!") {
			$_ = join(':', @e[0..(8-scalar(@addr))]);
		}
	}
	@addr = split(/:/, join(':', @addr));
	$_ = hex($_) foreach @addr;
	return pack("n*", @addr);
}

sub ip6_swap
{
	return pack("V*", unpack("N*", shift @_));
}
